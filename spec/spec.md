# ミニテンプレート言語 Natsuzora 仕様書 v2.0

## 0. メタ情報

- Version: 2.0
- Status: 確定
- 対象実装: Rust / Ruby（共通仕様）
- 用途: 静的 HTML 生成、Rails プレビュー共有テンプレート

---

## 1. 目的と設計理念

Natsuzora は「表示専用」の極小テンプレート言語であり、以下を満たすことを目標とする。

- ロジックは最小限で予測可能
- すべての評価は決定的
- デフォルトですべての出力を HTML エスケープし、安全性を確保
- 表示用 JSON データをそのまま描画でき、副作用や外部参照は一切行わない

テンプレートはHTMLを生成するためだけに使用し、DB 参照・HTTP リクエスト・乱数などの計算／副作用は持たない。

---

## 2. 実行モデル

1. ルート JSON オブジェクト 1 個を入力として受け取る。
2. テンプレートを上から順に評価し、ノードをテキストに変換する。
3. 変数評価で得た値は必ず文字列化し、`{[#unsecure]}` 以外では HTML エスケープ後に出力する。
4. 評価中にエラーが発生した場合は即座にレンダリングを中断し、実行結果を返さない。

---

## 3. データモデル

### 3.1 許可される型

- 符号付き整数（integer）
- 文字列（UTF-8）
- 真偽値
- null
- 配列（上記型のみを要素に持つ）
- オブジェクト（上記型のみを値に持つ）

整数はJSONの制限により -9007199254740991 から 9007199254740991 までの値を持つ。それ以上・以下の数値が与えられた場合はエラーにしてもよい。

### 3.2 禁止される型・値

- 浮動小数点数（テンプレートに渡す前に必ず整数へ丸める）
- 時刻・日付型
- 関数、クロージャ、任意オブジェクト

### 3.3 文字列化ルール

| 入力値       | 文字列化結果                               |
|--------------|--------------------------------------------|
| 文字列       | そのまま（後述の HTML エスケープ適用）     |
| 数値         | `-?[0-9]+` 形式（0/正数に符号は付与しない）|
| null         | 空文字列 `""`                              |
| 真偽値       | **不可**（エラー）                         |
| 配列・オブジェクト | **不可**（エラー）                   |

### 3.4 Truthiness（`if` / `unless` 判定）

偽とみなす値は以下のみ。

- `false`
- `null`
- 数値 `0`
- 空文字列
- 要素数 0 の配列
- プロパティ数 0 のオブジェクト

上記以外は真とみなす。文字列の`"0"`は真とみなす。

---

## 4. 名前解決とスコープ

- ルートコンテキストは 1 つだけ存在する。
- ローカルスコープはスタックで管理される（`each` と `include` が push/pop を行う）。
- 名前解決は「最上位のローカル → 外側ローカル → ルート」の順序で行い、未定義ならエラー。
- シャドーイングは禁止。すでに存在する名前と同名のローカル変数を束縛してはならない。
  - 例外: include の引数 key は、ルートコンテキストおよびすべてのローカルスコープに同名が存在しても定義できる（シャドーイング検証をスキップする）。
- include の内部からは、呼び出し元のローカルスコープも参照可能（読み取り専用）。

---

## 5. 構文要素

テンプレートは以下のノードで構成される。

1. **テキスト**
   `{[` を含まない任意の文字列。解析時は「次の `{[` が現れる直前まで」を TEXT として扱う。

2. **変数展開**
   構文: `{[ path ]}`
   - `path` は識別子のドット区切り（例 `author.name`）。
   - 前後の空白は任意。
   - 評価結果は前述の規則で文字列化し、必ず HTML エスケープする。

3. **ブロック**
   `if` / `unless` / `each` / `unsecure` の 4 種類。詳細は次章。

4. **include（パーシャル）**
   別ファイルのテンプレートを挿入する。詳細は §7。

5. **コメント**
   構文: `{[! comment ]}`
   - `{[` の直後に `!` を置くことでコメントとなる。
   - `]}` までの内容は完全に無視され、出力には含まれない。
   - 複数行のコメントも可能。
   - AST ノードとしては存在しない（Lexer レベルでスキップされる）。

6. **空白制御**
   構文: `{[- ... ]}` および `{[ ... -]}`
   - `{[-`: 直前の空白を行頭まで削除する（行が空白のみの場合）
   - `-]}`: 直後の空白を行末まで削除する（改行も削除、行が空白のみの場合）
   - 両方を組み合わせて `{[- ... -]}` とすることも可能。
   - 行に非空白文字が含まれる場合は何もしない（安全性のため）。
   - Lexer レベルで処理される。

7. **デリミタエスケープ**
   構文: `{[{]}`
   - `{[` をリテラル文字列として出力する。
   - テンプレートの構文説明など、`{[` 自体を表示したい場合に使用する。
   - Lexer レベルで処理され、TEXT ノードとして `{[` を出力する。
   - `]}` は `{[` の直後に来ない限り通常のテキストとして扱われるため、エスケープ不要。
   - **制約**: `{[{]}` は厳密に 5 文字で固定。空白の挿入は一切許容されない（`{[ { ]}` は不可）。
   - **制約**: 空白制御との併用は不可（`{[-{]}` や `{[{-]}` は存在しない）。

### 5.1 空白の扱い

`{[ ... ]}` 内部の空白は以下の規則に従う:

**タグ開始 `{[` または `{[-` 直後:**
- `{[` と `#`/`>`/`/`/`!`/`{`/`-` の間に空白は許容されない（`{[#if`、`{[>`、`{[/if`、`{[!`、`{[{`、`{[-` のように直接続ける）。
- `{[-` と `#`/`>`/`/` の間にも空白は許容されない（`{[-#if`、`{[->`、`{[-/if` のように直接続ける）。
- `{[` または `{[-` と識別子の間に空白は許容される（例: `{[ name ]}`、`{[- name ]}`）。

**タグ終了 `]}` または `-]}` 直前:**
- `-]}` の `-` と `]}` の間に空白は許容されない。
- 識別子・キーワードと `-]}` の間に空白は許容される（例: `{[ name -]}`、`{[#if x -]}`）。

**その他:**
- `#` とキーワードの間の空白は許容される（例: `{[# if x]}`）。
- 識別子の前後の空白は許容される（例: `{[ name ]}`）。
- キーワードと式の間には少なくとも 1 つの空白が必要（例: `{[#if x]}` の `if` と `x` の間）。

### 5.2 HTML エスケープ

`{[#unsecure]}` 節外のすべての出力に対して、以下の置換を施す。

| 置換前 | 置換後  |
|--------|---------|
| `&`    | `&amp;` |
| `<`    | `&lt;`  |
| `>`    | `&gt;`  |
| `"`    | `&quot;`|
| `'`    | `&#39;` |

属性値／テキストいずれも同じ規則を適用し、追加の例外は設けない。

---

## 6. 制御構造

### 6.1 if ブロック

```
{[#if <expr>]}
  then 節
{[/if]}
```

```
{[#if <expr>]}
  then 節
{[#else]}
  else 節
{[/if]}
```

- `<expr>` は現在は PATH のみ。
- `{[#else]}` は 1 回まで。`/else` は存在しない。
- 真偽判定は §3.4 の truthiness を使用。
  - 真なら then 節のみ評価。
  - 偽なら else 節があれば評価し、なければ何も出力しない。
- `else` を単独で書く、または if 以外の場所で使うと構文エラー。

### 6.2 unless ブロック

```
{[#unless <expr>]}
  内容
{[/unless]}
```

- `<expr>` は現在は PATH のみ。
- `if` の逆条件として機能する。
- 真偽判定は §3.4 の truthiness を使用。
  - 偽なら内容を評価して出力する。
  - 真なら何も出力しない。
- `else` 節は持たない（`if` と `else` を使用すること）。

### 6.3 each ブロック

index_identを持つ構文と持たない構文がある。

index_identを持つ構文:

```
{[#each <path> as <item_ident>, <index_ident>]}
  ...
{[/each]}
```

index_identを持たない構文:

```
{[#each <path> as <item_ident>]}
  ...
{[/each]}
```

- `<path>` は必ず配列。配列以外なら実行時エラー。
- `as` は必須。`,` は任意。`,` を書いた場合は `<index_ident>` も必須。
- `item_ident` は現在要素、`index_ident` は 0 始まり整数。
- 各繰り返しで新しいローカルスコープを push し、終了時に pop する。
- シャドーイング禁止ルールにより、`item_ident` と `index_ident` は既存スコープの名前と衝突してはならず、同一 each 内で同名を指定することもできない。

### 6.4 unsecure ブロック

```
{[#unsecure]}
  ...
{[/unsecure]}
```

- ブロック内の出力は HTML エスケープしない。
- ネスト可能だが、効果は内側のみ（外側は通常のエスケープ）。
- `{[[ ... ]]}` などの代替記法は導入しない。

---

## 7. include（パーシャル）

実装は1つのinclude_rootを持つ。

実装はinclude_root以下のテンプレートファイルをパーシャルとして読み込むことができる。

### 7.1 基本構文

```
{[> name]}
{[> name key=value key2=value2]}
```

- `name`: `/`で始まるパーシャル論理名（詳細は後述）。
- `key`: 引数名（識別子）。
- `value`: PATH のみ。リテラルや式は不可。
- 引数は空白区切り、`=` 以外の区切り記号は使用しない。

### 7.2 name の規則

- `"/segment"` 形式で開始し、`/` 区切りで複数セグメントを持てる。
- 各セグメントは `[A-Za-z0-9_]+`。
- 禁止パターン: 空文字、`.`、`..`、`//`、`\`、`:`。
- name は論理名であり、テンプレート側でパス操作を行わない。
- 禁止パターンの検出は Lexer または Parser の段階で行い、エラーとする。
- `.` はセグメント文字 `[A-Za-z0-9_]` に含まれないため、Lexer レベルで name のトークン化が途中で終了する場合がある（例: `/../card` は `/` のみが name としてトークン化される）。

### 7.2.1 ファイル命名ルール

- 通常のテンプレート（エントリーポイントなど）は、ファイル名を `_` で始めてはならない。
- パーシャル（include 対象）は、ファイル名を必ず `_` で始める（例 `_card.tmpl`）。
- linter やビルドステップはこの命名ルール違反をエラーとして扱うこと。

### 7.3 引数名の規則

- `[A-Za-z][A-Za-z0-9_]*`（識別子と同じ規則、`_` 先頭禁止）
- 同一 include 内で重複禁止。
- 変数名と同名でもよい（シャドーイング禁止の例外）。

### 7.4 ファイル解決

既定の include_root は `shared/`。`name` を次の手順でファイルに変換する。

1. `include_root` を基点にする。
2. name を `/` で分割して階層を作る。
3. 最終要素に `_` を付けたファイル名へ変換する。
4. `.tmpl` 拡張子を付与する。

例: `{[> /components/card]}` → `shared/components/_card.tmpl`

### 7.5 評価手順

1. include を検出。
2. 引数の value を現在のスコープで評価（未定義ならエラー）。
3. 新しいローカルスコープを push し、引数 key に値を束縛。
4. パーシャル AST を評価。root コンテキストは共有。
5. 評価終了後にスコープを pop。

### 7.6 循環防止

- include 開始時に name をスタックへ push。
- 同じ name が既にスタック内にあれば循環とみなしエラー。
- 終了時に pop して呼び出し元へ戻る。

### 7.7 セキュリティ

- include_root 外へのアクセスは禁止。パストラバーサル（`../` 等）やシンボリックリンク逸脱も検出した時点でエラー。
- 実装はファイルパス正規化後に必ず include_root 配下か検証する。

---

## 8. エラー処理

以下はいずれも致命的エラーであり、レンダリングを即時に中断する。

- 未定義変数、未定義パス
- 型不一致（例: 配列以外に each を適用、真偽値の文字列化など）
- include 先が存在しない、または include_root 外
- include の循環
- 構文違反（ブロック未閉、`else` 乱用、`unless` に `else` を使用 等）
- 数値型違反（整数以外を渡す）

---

## 9. 非機能要件

- 評価中は副作用を発生させない。
- IO 禁止（テンプレート読み込みは除く）。
- DB アクセス、HTTP リクエスト禁止。必要なデータは事前に JSON 化する。
- 現在時刻取得、乱数、環境変数参照などの非決定的操作は行わない。

---

## 10. 衝突回避と予約語

### 10.1 予約語

`if`, `unless`, `else`, `each`, `as`, `unsecure`, `true`, `false`, `null`, `include` は識別子として使用不可（将来拡張の衝突を避けるため）。

- 予約語を変数展開（`{[ if ]}`）や each 変数（`{[#each items as true]}`）として使用した場合は構文エラーとする。
- 実装において、Lexer は `if`, `else`, `each`, `as`, `unsecure` をキーワードトークンとして認識し、Parser が識別子を期待する位置でこれらを検出した場合にエラーを発生させる。

### 10.2 プレフィックス禁止

- `_` で始まる識別子（例 `_item`）は Parser でエラーとする。
- `@` を含む識別子（例 `@index`, `i@`）は Lexer でエラーとする（`@` は識別子文字 `[A-Za-z0-9_]` に含まれないため、Lexer が不正な文字として検出する）。

### 10.3 ルートキーとの衝突

- `each` の `item_ident` / `index_ident` は、ルート JSON のトップレベルキーと同名にしてはならない。

### 10.4 ローカルスコープ衝突

- `item_ident` / `index_ident` は外側スコープ内の他ローカル変数と同名不可。

### 10.5 item/index 同名禁止

- 同一 `each` ブロック内で `item_ident` と `index_ident` を同じ名前にしてはならない。

---

## 11. 互換性ポリシー

- 本仕様 v2.0 に準拠する実装は、同一のテンプレートと入力データから常に同一の出力を生成しなければならない。
- 仕様変更を行う際は、メジャーまたはマイナーバージョンを必ず更新する。

---

## 12. 実装メモ（非規範）

- 字句解析では TEXT と `{[ ... ]}` を交互に切り出すと単純になる。
- `{[ ... ]}` の先頭記号で分類すると実装が容易:
  - `#`: ブロック開始
  - `/`: ブロック終了
  - `>`: include
  - `!`: コメント（`]}` までスキップ）
  - `-`: 空白制御（直前の空白を行頭まで削除）
  - `{`: デリミタエスケープ（`{[` をリテラル出力）
  - 上記以外: 変数展開
- `-]}` は空白制御（直後の空白を行末まで削除）
- パーシャルは評価結果ではなく AST をキャッシュすると効率的（挿入ごとに再パースしない）。

### 12.1 `/` の二重用途

`/` は以下の 2 つの文脈で使用される:

- **ブロック終了**: `{[/if]}`, `{[/each]}`, `{[/unsecure]}`
- **include 名の開始**: `{[> /card]}`, `{[> /components/header]}`

区別方法: `>` の直後（空白を除く）に現れる `/` は include 名の開始として扱う。それ以外の `/` はブロック終了記号として扱う。
