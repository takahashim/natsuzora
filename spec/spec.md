# ミニテンプレート言語 Natsuzora 仕様書 v4.0

## 0. メタ情報

- Version: 4.0
- Status: 確定
- 対象実装: Rust / Ruby （共通仕様）
- ファイル拡張子: `.ntzr`

## 1. 概要と設計理念

Natsuzoraは、HTML生成に特化した極小テンプレート言語である。

### 1.1 設計理念

- ロジックは最小限で予測可能: 関数呼び出しや演算子は禁止する。条件分岐は値の有無や型に基づく真偽判定のみに制限する。
- 決定的な評価: 同一のテンプレートと同一の入力データからは、常に同一の出力が得られる。現在時刻、乱数、外部IOなどの非決定的な要素は一切排除する。
- デフォルトで安全: 明示的な指定がない限り、すべての変数値はHTMLエスケープされる。
- 副作用の排除: データの参照のみを行い、状態の変更や外部への副作用を持たない。DB参照、HTTPリクエスト、環境変数アクセスなども行わない。

### 1.2 実行モデル

1. ルートとなるJSONオブジェクトを1つ入力として受け取る。
2. テンプレートを上から順に評価する。この際、`include`構文は指定された別テンプレートの内容をその場で評価・挿入するトリガーとなり、最終的に各ノードがテキストに変換される。
3. 変数評価で得た値は、後述の規則に従い文字列化し、原則としてHTMLエスケープ後に出力する。
4. 評価中にエラーが発生した場合は、即座にレンダリングを中断し、部分的な結果を返さない。

## 2. 字句構造 (Lexical Structure)

ソースコードはUTF-8エンコーディングされた文字列として扱われる。

### 2.1 字句定義

- Whitespace(空白): スペース (`U+0020`)、タブ (`U+0009`)、改行 (LF `U+000A`, CR `U+000D`)。
- Identifier(識別子): `[A-Za-z][A-Za-z0-9_]*` にマッチする文字列のうち、予約語以外のもの。`_`で始まる識別子は予約されており使用できない。
- Path(パス): `Identifier` をドット `.` で連結したもの（例: `author.name`）。
- Include Name(インクルード名): `/`で始まり、`Identifier`をスラッシュ`/`で連結した論理名（例: `/components/card`）。
- Tag(タグ): `{[` で始まり `]}` で終わる構文要素。

### 2.2 予約語

以下の単語は識別子として使用できない。字句解析または構文解析の段階でエラーとする。

`if`, `unless`, `else`, `each`, `as`, `in`, `of`, `unsecure`, `true`, `false`, `null`, `include`

### 2.3 デリミタとエスケープ

- 開始デリミタ: `{[`
- 終了デリミタ: `]}`
- デリミタエスケープ: `{[{]}`
  - これは単一のトークンとして扱われ、テキストノード `{[` として出力される。
  - 制約: 文字列 `"{[{]}"}` と完全に一致する必要があり、内部に空白を含めてはならない。また、空白制御 `{[-` `-]}` との併用はできない。

## 3. データモデル

### 3.1 型システム

テンプレートエンジン内部で扱える型は以下に限定される。

|      型     | 説明・制約                                                                     |
|-------------|--------------------------------------------------------------------------------|
| Integer     | 符号付き整数。`-(2^53-1)`から`2^53-1`の範囲（`Number.MAX_SAFE_INTEGER`準拠）。 |
| String      | UTF-8 文字列。                                                                 |
| Boolean     | `true` または `false`。                                                        |
| Null        | 値が存在しないことを示す `null`。                                              |
| Array       | 上記の型を要素に持つ順序付きリスト。                                           |
| Map(Object) | 文字列をキーとし、上記の型を値に持つ連想配列。                                 |

### 3.2 禁止される値

入力データに以下の型が含まれていた場合、実行時エラーとして処理を中断する。

- 浮動小数点数 (ただし、`3.0`のように整数とみなせる値はIntegerとして扱う)
- 日付・時刻型
- 関数、クロージャ、その他オブジェクト

### 3.3 Truthiness (真偽判定)

`if`, `unless` での評価において、以下の値は **偽 (Falsy)** とみなす。

- **Boolean**: `false`
- **Null**: `null`
- **Integer**: `0`
- **String**: 空文字列 `""`
- **Array**: 要素数0の配列 `[]`
- **Map**: エントリ数0のオブジェクト `{}`

これら以外の全ての値は **真 (Truthy)** とみなす（例: 文字列の `"0"`）。

### 3.4 文字列化 (Stringification)

変数展開時の文字列変換ルールは以下の通りである。

| 入力値       | 文字列化結果                               |
|--------------|--------------------------------------------|
| String       | そのまま（後述のHTMLエスケープ適用）       |
| Integer      | 10進数表記（例: `123`, `-45`）             |
| Null         | **不可**（エラー）※ `?`修飾子で変更可      |
| Boolean      | **不可**（エラー）                         |
| Array / Map  | **不可**（エラー）                         |

## 4. 構文 (Syntax)

### 4.1 タグの種類と例

Natsuzoraテンプレートは、以下の種類のタグをサポートする。

| 種類         | 例                       | 説明                               |
|--------------|--------------------------|------------------------------------|
| 変数展開     | `{[ user.name ]}`        | HTMLエスケープして値を出力         |
| 変数修飾子   | `{[ user.name? ]}`       | nullや空文字列の扱いを制御         |
| ifブロック   | `{[#if logged_in]}`      | 条件によって内容を評価             |
| unlessブロック | `{[#unless logged_in]}`  | 条件が偽の場合に内容を評価         |
| eachブロック | `{[#each items as item]}`| 配列の要素を繰り返し評価           |
| elseタグ     | `{[#else]}`              | ifブロックの代替内容を定義         |
| unsecure出力 | `{[!unsecure html_content]}` | HTMLエスケープせず値を出力       |
| include      | `{[!include /c/header]}` | 別ファイルを読み込み評価           |
| コメント     | `{[% This is a comment ]}` | テンプレート中にコメントを記述   |
| デリミタエスケープ | `{[{]}`            | リテラルの`{[`を出力               |
| ブロック終了 | `{[ /if ]}`             | ブロックの終わりを示す             |

### 4.2 構文規則 (EBNF)

```ebnf
TEMPLATE      := NODE*
NODE          := TEXT | VAR | IF_BLOCK | UNLESS_BLOCK | EACH_BLOCK | UNSECURE | INCLUDE

OPEN          := "{[" ["-"]
CLOSE         := ["-"] "]}"
WS            := (" " | "\t" | "\r" | "\n")+
IDENT         := /[A-Za-z][A-Za-z0-9_]*/
PATH          := IDENT ("." IDENT)*
MODIFIER      := "?" | "!"
EXPR          := PATH

VAR           := OPEN WS? PATH MODIFIER? WS? CLOSE

IF_BLOCK      := IF_OPEN NODE* (ELSE_OPEN NODE*)? IF_CLOSE
IF_OPEN       := OPEN "#" WS? "if" WS+ EXPR WS? CLOSE
ELSE_OPEN     := OPEN "#" WS? "else" WS? CLOSE
IF_CLOSE      := OPEN "/" WS? "if" WS? CLOSE

UNLESS_BLOCK  := UNLESS_OPEN NODE* UNLESS_CLOSE
UNLESS_OPEN   := OPEN "#" WS? "unless" WS+ EXPR WS? CLOSE
UNLESS_CLOSE  := OPEN "/" WS? "unless" WS? CLOSE

EACH_BLOCK    := EACH_OPEN NODE* EACH_CLOSE
EACH_OPEN     := OPEN "#" WS? "each" WS+ EXPR WS+ "as" WS+ IDENT WS? CLOSE
EACH_CLOSE    := OPEN "/" WS? "each" WS? CLOSE

UNSECURE      := OPEN "!unsecure" WS+ PATH WS? CLOSE

INCLUDE       := OPEN "!include" WS+ NAME (WS+ INCLUDE_ARG)* WS? CLOSE
INCLUDE_ARG   := IDENT WS? "=" WS? PATH
NAME          := "/" IDENT ("/" IDENT)*

COMMENT       := "{[%" COMMENT_TEXT CLOSE
              | "{[-%" COMMENT_TEXT CLOSE
```

注:
- `OPEN` の `["-"]` はオプションの空白制御フラグ（trim）を表す。`CLOSE` も同様。
- `COMMENT` および `DELIMITER_ESCAPE`（`{[{]}`）はLexerレベルで処理され、ASTには出現しない。

### 4.3 テキストと空白制御

タグ以外の部分はテキストノードとしてそのまま出力される。

#### 4.3.1 左 trim `{[-`

左 trim は、タグ直前のテキストの「同一行上の末尾区間」が空白（スペース / タブ）のみの場合にだけ適用する。

手順(参考):
1. 直前のテキストノードを取得する。
2. そのテキストの「直近の改行以降」を末尾区間として取り出す。
3. 末尾区間が空白のみなら、その区間を削除する。
4. 末尾区間に非空白文字が含まれる場合は何もしない。

例: `line1\n  {[-` → `line1\n`（末尾区間 `"  "` が空白のみなので削除）

#### 4.3.2 右 trim `-]}`

右 trim は、タグ直後のテキストの行頭側が「空白のみ＋改行」のときだけ適用する。

手順(参考):
1. タグ直後のテキスト先頭のスペース / タブを読み飛ばす。
2. 次が改行なら、その改行1つ（`\n` または `\r\n` または `\r`）を含めて削除する。
3. 次が改行でなければ何もしない。
4. テキストが空白のみで終わる場合は空文字になる。

例: `-]}  \nafter` → `after`（空白＋改行を削除）

#### 4.3.3 trim の適用範囲

trim は変数、ブロック開始/終了、include、コメントの各タグで同じ規則を適用する。trim 記号 `-` 自体は出力に現れない。

#### 4.3.4 タグ内部の空白

- `{[`（または `{[-`）とタグ種別文字 (`#`, `/`, `!`, `%`, `{`) の間に空白は許容されない。
  - 正: `{[#if x]}`, `{[!include /card]}`
  - 誤: `{[ #if x]}`, `{[ !include /card]}`
- キーワード（`if`, `each`など）と式の間に少なくとも1つの空白が必要である。
- それ以外の場所（例: `{[ path ]}` の `path` の前後）でも空白が許容される場合がある。

### 4.4 変数展開 (Interpolation)

```bnf
VAR_NODE ::= TAG_OPEN WS? PATH MODIFIER? WS? TAG_CLOSE
MODIFIER ::= "?" | "!"
```
- `path`で指定された値をコンテキストから解決し、文字列化して出力する。
- 出力はデフォルトでHTMLエスケープされる (`&`, `<`, `>`, `"`, `'`)。
- 変数修飾子: `path` の末尾に修飾子を付与し、`null` や空文字列の扱いを制御できる。

| 修飾子 | 構文例 | undefined | null | `""` | 値あり |
|--------|--------|-----------|------|------|--------|
| (なし) | `{[ name ]}` | エラー | エラー | 空出力 | 出力 |
| `?` | `{[ name? ]}` | エラー | 空出力 | 空出力 | 出力 |
| `!` | `{[ name! ]}` | エラー | エラー | エラー | 出力 |

正例/誤例:
- 正: `{[ user.name ]}`, `{[ value? ]}`, `{[ value! ]}`
- 誤: `{[ .name ]}`（パスの先頭にドット）、`{[ value!? ]}`（修飾子の重複）

### 4.5 制御構文と特殊タグ

#### 4.5.1 if / unless ブロック

```bnf
IF_BLOCK ::= IF_OPEN NODE* (ELSE_OPEN NODE*)? IF_CLOSE
UNLESS_BLOCK ::= UNLESS_OPEN NODE* UNLESS_CLOSE
```
- `if`: パスがTruthyならthen節を、Falsyならelse節（存在すれば）を評価する。
- `unless`: パスがFalsyの場合のみ内部を評価する。`else`節は持てない。
- `else if` は存在しない。

正例/誤例:
- 正: `{[#if x]}A{[#else]}B{[/if]}`
- 誤: `{[#else]}A{[/if]}`（`else`が`if`ブロック外）

#### 4.5.2 each ブロック

```bnf
EACH_BLOCK ::= EACH_OPEN NODE* EACH_CLOSE
EACH_OPEN  ::= TAG_OPEN HASH "each" PATH "as" IDENT TAG_CLOSE
```
- パスの評価結果はArrayでなければならない。
- ループごとに新しいローカルスコープを作成し、要素を `as` で指定された変数名に束縛する。

正例/誤例:
- 正: `{[#each items as item]}{[ item ]}{[/each]}`
- 誤: `{[#each items]}{[/each]}`（`as`と束縛名が欠落）

#### 4.5.3 unsecure (エスケープなし出力)

```bnf
UNSECURE_OUTPUT ::= TAG_OPEN "!" "unsecure" PATH TAG_CLOSE
```
- `path`の値をHTMLエスケープせずに出力する。`path`で示すテキストファイルの内容が適切ではない場合、生成結果はHTMLとして正しい文書にならない危険性がある。使用には注意が必要である。

正例/誤例:
- 正: `{[!unsecure html ]}`
- 誤: `{[ !unsecure html ]}`（`{[`と`!`の間に空白）

#### 4.5.4 コメント

```bnf
COMMENT ::= TAG_OPEN "%"COMMENT_CONTENT TAG_CLOSE
```
- `{[%` から `]}` までの内容は完全に無視され、出力に含まれない。
- コメント開始記号 `%` の前に空白を置くことはできない（`{[ %` は不正）。
- 空白制御（trim）との併用が可能である:
  - 左 trim 付き: `{[-% ... ]}`
  - 右 trim 付き: `{[% ... -]}`
  - 両側 trim 付き: `{[-% ... -]}`

正例/誤例:
- 正: `{[% comment ]}`, `{[-% c -]}`
- 誤: `{[ % comment ]}`（`{[`と`%`の間に空白）

#### 4.5.5 include (構文)

```bnf
INCLUDE_NODE ::= TAG_OPEN "!" "include" NAME (INCLUDE_ARG)* TAG_CLOSE
INCLUDE_ARG  ::= IDENT "=" PATH
```
- `NAME`: `/`で始まるパーシャルの論理名。`[A-Za-z][A-Za-z0-9_]*` のセグメントを `/` で連結したもの。`.` `..` `\` `//` などは禁止。
- `INCLUDE_ARG`: `key=value` 形式でパーシャルに渡す引数。`key`は識別子、`value`はパス参照のみ。

正例/誤例:
- 正: `{[!include /card title=item.title ]}`
- 誤: `{[!include / ]}`（名前が`/`のみ）、`{[ !include /card ]}`（`{[`と`!`の間に空白）

### 4.6 パーシャルの評価

`include` タグは、指定された別のテンプレート（パーシャル）を読み込み、その場で評価・挿入する機能である。評価のフローは以下の通りとなる。

#### 4.6.1 ファイル解決
1. 実装は `include_root` を1つ持つ（例: `shared/`）。
2. `NAME` (`/components/card`など) を `/` で分割し、`include_root` からの相対パスを構築する。
3. 最終セグメントのファイル名の先頭に `_` を付与し、`.ntzr` 拡張子を付ける。
   (例: `{[!include /c/card]}` → `include_root/c/_card.ntzr`)
4. パーシャルとして読み込まれるファイルは、必ず `_` で始まる必要がある。

#### 4.6.2 スコープと評価
1. `include` タグの引数 `value` (パス) を、呼び出し元のスコープで評価する。
2. パーシャルのための新しいローカルスコープを作成する。
3. 評価した引数の値を、引数名 `key` として新しいスコープに束縛する。
4. パーシャルのAST（抽象構文木）を、この新しいスコープの下で評価する。
5. 呼び出し元のスコープ（親スコープ）の変数も、読み取り専用で参照可能である。
6. 評価が完了すると、このローカルスコープは破棄される。

#### 4.6.3 循環参照
includeの呼び出し階層（スタック）を追跡し、同じ `NAME` のパーシャルが再帰的に呼ばれた場合（例: `a.ntzr` が `b.ntzr` を include し、`b.ntzr` が再び `a.ntzr` を include する）、循環参照とみなし実行時エラーとする。

#### 4.6.4 セキュリティ
実装は、解決されたファイルパスが `include_root` ディレクトリ配下にあることを必ず検証しなければならない。パストラバーサル (`../`) やシンボリックリンクによる `include_root` 外へのアクセスは検出し、エラーとしなければならない。

## 5. 名前解決とスコープ (Scoping)

### 5.1 スコープルール

- スコープスタック: ルートコンテキストを底とし、`each`, `include` によってローカルスコープが積み上がる。
- 解決順序: 名前解決は「現在のローカルスコープ → 外側のローカルスコープ → ルート」の順序で行う。
- 未定義: 探索しても見つからない場合は実行時エラーとする。

### 5.2 衝突回避とシャドーイング

- シャドーイング禁止: `each` の反復変数が、自身が属するスコープから見える外側の変数名を再定義（シャドーイング）することは禁止される。
- 例外: `include` の引数名は、呼び出し元の変数と重複してもよい（引数が優先される）。
- 識別子プレフィックス: `_`で始まる識別子は内部用に予約されており、変数名として使用すると構文エラーとなる。
- ルートキーとの衝突: `each` の反復変数名は、ルートJSONのトップレベルキーと同名であってはならない。

## 6. エラーハンドリング

以下の事象が発生した場合、即座に処理を中断し、エラーを呼び出し元へ通知する。

- 構文エラー: パース失敗、タグの閉じ忘れ、不正なトークン、予約語の使用など。
- 未定義参照: 存在しない変数（パス）へのアクセス。
- 型エラー: `each`の対象が配列でない、文字列化できない型（boolean, array, object）を出力しようとした、など。
- Includeエラー: 対象ファイルが見つからない、`include_root`外へのアクセス、循環参照など。
- 衝突・シャドーイング違反: 禁止されたコンテキストでの変数名の重複。
